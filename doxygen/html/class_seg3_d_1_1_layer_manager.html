<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.10"/>
<title>Seg3D: Seg3D::LayerManager Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="seg3d2_128.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Seg3D
   &#160;<span id="projectnumber">2.4</span>
   </div>
   <div id="projectbrief">Seg3D is a free volume segmentation and processing tool developed by the NIH Center for Integrative Biomedical Computing at the University of Utah Scientific Computing and Imaging (SCI) Institute.</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.10 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><b>Seg3D</b></li><li class="navelem"><a class="el" href="class_seg3_d_1_1_layer_manager.html">LayerManager</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#pub-attribs">Public Attributes</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="#friends">Friends</a> &#124;
<a href="class_seg3_d_1_1_layer_manager-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">Seg3D::LayerManager Class Reference</div>  </div>
</div><!--header-->
<div class="contents">
<div class="dynheader">
Inheritance diagram for Seg3D::LayerManager:</div>
<div class="dyncontent">
 <div class="center">
  <img src="class_seg3_d_1_1_layer_manager.png" usemap="#Seg3D::LayerManager_map" alt=""/>
  <map id="Seg3D::LayerManager_map" name="Seg3D::LayerManager_map">
<area href="class_core_1_1_state_handler.html" alt="Core::StateHandler" shape="rect" coords="0,112,155,136"/>
<area href="class_core_1_1_connection_handler.html" title="A simple class for managing connections. " alt="Core::ConnectionHandler" shape="rect" coords="0,56,155,80"/>
</map>
 </div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a9d8cf978b08c853396645469ca069207"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a9d8cf978b08c853396645469ca069207"></a>
typedef Core::StateEngine::mutex_type&#160;</td><td class="memItemRight" valign="bottom"><b>mutex_type</b></td></tr>
<tr class="separator:a9d8cf978b08c853396645469ca069207"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a51e983ec09c48fc03a87b1aec9b9df24"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a51e983ec09c48fc03a87b1aec9b9df24"></a>
typedef Core::StateEngine::lock_type&#160;</td><td class="memItemRight" valign="bottom"><b>lock_type</b></td></tr>
<tr class="separator:a51e983ec09c48fc03a87b1aec9b9df24"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af5b4b2b6539f8fbde47c9edcae1f866f"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="class_seg3_d_1_1_layer.html#abc913cc3a6cbf41f89d25fc7dca1991a">Layer::filter_key_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_seg3_d_1_1_layer_manager.html#af5b4b2b6539f8fbde47c9edcae1f866f">filter_key_type</a></td></tr>
<tr class="separator:af5b4b2b6539f8fbde47c9edcae1f866f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a444ff6a6b18ddbbf062e682a2c0f56bb"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a444ff6a6b18ddbbf062e682a2c0f56bb"></a>
typedef std::vector&lt; int &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>id_count_type</b></td></tr>
<tr class="separator:a444ff6a6b18ddbbf062e682a2c0f56bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a41c39a59b46b471e2d88fa2fe174c8f6"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_seg3_d_1_1_layer_manager.html#a41c39a59b46b471e2d88fa2fe174c8f6">get_session_priority</a> ()</td></tr>
<tr class="separator:a41c39a59b46b471e2d88fa2fe174c8f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5892b54bd1041723476d5dced0240abc"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_seg3_d_1_1_layer_manager.html#a5892b54bd1041723476d5dced0240abc">get_groups</a> (std::vector&lt; LayerGroupHandle &gt; &amp;groups)</td></tr>
<tr class="separator:a5892b54bd1041723476d5dced0240abc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abe8dc4a433129db36e6707939b9f0ce6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_seg3_d_1_1_layer_manager.html#abe8dc4a433129db36e6707939b9f0ce6">get_layers</a> (std::vector&lt; LayerHandle &gt; &amp;layers)</td></tr>
<tr class="separator:abe8dc4a433129db36e6707939b9f0ce6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a86a058090797095cce9901312ad86f41"><td class="memItemLeft" align="right" valign="top">LayerGroupHandle&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_seg3_d_1_1_layer_manager.html#a86a058090797095cce9901312ad86f41">find_group</a> (const std::string &amp;group_id)</td></tr>
<tr class="separator:a86a058090797095cce9901312ad86f41"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8265add81a4791f4d70ca7029c4246df"><td class="memItemLeft" align="right" valign="top">LayerGroupHandle&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_seg3_d_1_1_layer_manager.html#a8265add81a4791f4d70ca7029c4246df">find_group</a> (ProvenanceID provenance_id)</td></tr>
<tr class="separator:a8265add81a4791f4d70ca7029c4246df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a589090867f58411c3acec2a2730c0764"><td class="memItemLeft" align="right" valign="top">LayerHandle&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_seg3_d_1_1_layer_manager.html#a589090867f58411c3acec2a2730c0764">find_layer_by_id</a> (const std::string &amp;layer_id, SandboxID sandbox=-1)</td></tr>
<tr class="separator:a589090867f58411c3acec2a2730c0764"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a44425d3d5700aca9e2c805a52db89a4b"><td class="memItemLeft" align="right" valign="top">LayerHandle&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_seg3_d_1_1_layer_manager.html#a44425d3d5700aca9e2c805a52db89a4b">find_layer_by_name</a> (const std::string &amp;layer_name, SandboxID sandbox=-1)</td></tr>
<tr class="separator:a44425d3d5700aca9e2c805a52db89a4b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ba7e81deaa0836d626c6b56a5beafbb"><td class="memItemLeft" align="right" valign="top">LayerHandle&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_seg3_d_1_1_layer_manager.html#a7ba7e81deaa0836d626c6b56a5beafbb">find_layer_by_provenance_id</a> (ProvenanceID provenance_id, SandboxID sandbox=-1)</td></tr>
<tr class="separator:a7ba7e81deaa0836d626c6b56a5beafbb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af9dc1cc52b7d354d3fdfb349b80fa0e3"><td class="memItemLeft" align="right" valign="top">DataLayerHandle&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_seg3_d_1_1_layer_manager.html#af9dc1cc52b7d354d3fdfb349b80fa0e3">find_data_layer_by_id</a> (const std::string &amp;layer_id, SandboxID sandbox=-1)</td></tr>
<tr class="separator:af9dc1cc52b7d354d3fdfb349b80fa0e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a32afbc14bf7e4d50a1856134918dc545"><td class="memItemLeft" align="right" valign="top">MaskLayerHandle&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_seg3_d_1_1_layer_manager.html#a32afbc14bf7e4d50a1856134918dc545">find_mask_layer_by_id</a> (const std::string &amp;layer_id, SandboxID sandbox=-1)</td></tr>
<tr class="separator:a32afbc14bf7e4d50a1856134918dc545"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac991ad9a369f330e27428fdff5e3570f"><td class="memItemLeft" align="right" valign="top">LayerHandle&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_seg3_d_1_1_layer_manager.html#ac991ad9a369f330e27428fdff5e3570f">get_active_layer</a> ()</td></tr>
<tr class="separator:ac991ad9a369f330e27428fdff5e3570f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa9fecbfb0bc74ca81adc4fd315ea17bb"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_seg3_d_1_1_layer_manager.html#aa9fecbfb0bc74ca81adc4fd315ea17bb">get_layer_names</a> (std::vector&lt; LayerIDNamePair &gt; &amp;layer_names, int type=Core::VolumeType::ALL_E)</td></tr>
<tr class="separator:aa9fecbfb0bc74ca81adc4fd315ea17bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a00616e69ce19220bef40a26fdbb7e271"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_seg3_d_1_1_layer_manager.html#a00616e69ce19220bef40a26fdbb7e271">get_group_position</a> (LayerGroupHandle group)</td></tr>
<tr class="separator:a00616e69ce19220bef40a26fdbb7e271"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeaa1d8d15a73611aa60c80d4e7ccce3b"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_seg3_d_1_1_layer_manager.html#aeaa1d8d15a73611aa60c80d4e7ccce3b">is_sandbox</a> (SandboxID sandbox_id)</td></tr>
<tr class="separator:aeaa1d8d15a73611aa60c80d4e7ccce3b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7e3fa690d4cc3065c23eeb95fc29dc50"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a7e3fa690d4cc3065c23eeb95fc29dc50"></a>
LayerSceneHandle&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_seg3_d_1_1_layer_manager.html#a7e3fa690d4cc3065c23eeb95fc29dc50">compose_layer_scene</a> (size_t viewer_id)</td></tr>
<tr class="memdesc:a7e3fa690d4cc3065c23eeb95fc29dc50"><td class="mdescLeft">&#160;</td><td class="mdescRight">Take an atomic snapshot of visual properties of layers for rendering in the specified viewer. <br /></td></tr>
<tr class="separator:a7e3fa690d4cc3065c23eeb95fc29dc50"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:addde2e899e3c1e1f92691a2c8c001401"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="addde2e899e3c1e1f92691a2c8c001401"></a>
Core::BBox&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_seg3_d_1_1_layer_manager.html#addde2e899e3c1e1f92691a2c8c001401">get_layers_bbox</a> ()</td></tr>
<tr class="memdesc:addde2e899e3c1e1f92691a2c8c001401"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the bounding box of all layers. <br /></td></tr>
<tr class="separator:addde2e899e3c1e1f92691a2c8c001401"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aabbb24c4cf485b353550efedd0cfda9d"><td class="memItemLeft" align="right" valign="top">mutex_type &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_seg3_d_1_1_layer_manager.html#aabbb24c4cf485b353550efedd0cfda9d">get_mutex</a> ()</td></tr>
<tr class="separator:aabbb24c4cf485b353550efedd0cfda9d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_class_core_1_1_state_handler"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_class_core_1_1_state_handler')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="class_core_1_1_state_handler.html">Core::StateHandler</a></td></tr>
<tr class="memitem:ae1c483fa1d5fc61af57e4d9e3c504a94 inherit pub_methods_class_core_1_1_state_handler"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae1c483fa1d5fc61af57e4d9e3c504a94"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>StateHandler</b> (const std::string &amp;type_str, bool auto_id)</td></tr>
<tr class="separator:ae1c483fa1d5fc61af57e4d9e3c504a94 inherit pub_methods_class_core_1_1_state_handler"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1c9bec67a1a8262d70826c745f017870 inherit pub_methods_class_core_1_1_state_handler"><td class="memTemplParams" colspan="2"><a class="anchor" id="a1c9bec67a1a8262d70826c745f017870"></a>
template&lt;class HANDLE , class T &gt; </td></tr>
<tr class="memitem:a1c9bec67a1a8262d70826c745f017870 inherit pub_methods_class_core_1_1_state_handler"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_core_1_1_state_handler.html#a1c9bec67a1a8262d70826c745f017870">add_state</a> (const std::string &amp;key, HANDLE &amp;state, const T &amp;default_value)</td></tr>
<tr class="memdesc:a1c9bec67a1a8262d70826c745f017870 inherit pub_methods_class_core_1_1_state_handler"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add a local state variable with default value. <br /></td></tr>
<tr class="separator:a1c9bec67a1a8262d70826c745f017870 inherit pub_methods_class_core_1_1_state_handler"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5d3f245c69695003d991cb12c2e721ee inherit pub_methods_class_core_1_1_state_handler"><td class="memTemplParams" colspan="2"><a class="anchor" id="a5d3f245c69695003d991cb12c2e721ee"></a>
template&lt;class HANDLE , class T &gt; </td></tr>
<tr class="memitem:a5d3f245c69695003d991cb12c2e721ee inherit pub_methods_class_core_1_1_state_handler"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_core_1_1_state_handler.html#a5d3f245c69695003d991cb12c2e721ee">add_state</a> (const std::string &amp;key, HANDLE &amp;state, const T &amp;default_value, const T &amp;min_value, const T &amp;max_value, const T &amp;step)</td></tr>
<tr class="memdesc:a5d3f245c69695003d991cb12c2e721ee inherit pub_methods_class_core_1_1_state_handler"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add a local state variable with default value and min and max. <br /></td></tr>
<tr class="separator:a5d3f245c69695003d991cb12c2e721ee inherit pub_methods_class_core_1_1_state_handler"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1211c00d3bc73fba1c09a5d01db5e8ae inherit pub_methods_class_core_1_1_state_handler"><td class="memTemplParams" colspan="2"><a class="anchor" id="a1211c00d3bc73fba1c09a5d01db5e8ae"></a>
template&lt;class HANDLE &gt; </td></tr>
<tr class="memitem:a1211c00d3bc73fba1c09a5d01db5e8ae inherit pub_methods_class_core_1_1_state_handler"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_core_1_1_state_handler.html#a1211c00d3bc73fba1c09a5d01db5e8ae">add_state</a> (const std::string &amp;key, HANDLE &amp;state)</td></tr>
<tr class="memdesc:a1211c00d3bc73fba1c09a5d01db5e8ae inherit pub_methods_class_core_1_1_state_handler"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add a local state variable without default value. <br /></td></tr>
<tr class="separator:a1211c00d3bc73fba1c09a5d01db5e8ae inherit pub_methods_class_core_1_1_state_handler"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af70578dcd65e270d8220d562c3771ef4 inherit pub_methods_class_core_1_1_state_handler"><td class="memTemplParams" colspan="2"><a class="anchor" id="af70578dcd65e270d8220d562c3771ef4"></a>
template&lt;class HANDLE &gt; </td></tr>
<tr class="memitem:af70578dcd65e270d8220d562c3771ef4 inherit pub_methods_class_core_1_1_state_handler"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_core_1_1_state_handler.html#af70578dcd65e270d8220d562c3771ef4">add_state</a> (const std::string &amp;key, HANDLE &amp;state, const std::string &amp;default_option, const std::string &amp;option_list)</td></tr>
<tr class="memdesc:af70578dcd65e270d8220d562c3771ef4 inherit pub_methods_class_core_1_1_state_handler"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add a local state variable with option list. <br /></td></tr>
<tr class="separator:af70578dcd65e270d8220d562c3771ef4 inherit pub_methods_class_core_1_1_state_handler"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2a6850c97f206e6302d94b7695efb671 inherit pub_methods_class_core_1_1_state_handler"><td class="memTemplParams" colspan="2"><a class="anchor" id="a2a6850c97f206e6302d94b7695efb671"></a>
template&lt;class HANDLE &gt; </td></tr>
<tr class="memitem:a2a6850c97f206e6302d94b7695efb671 inherit pub_methods_class_core_1_1_state_handler"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_core_1_1_state_handler.html#a2a6850c97f206e6302d94b7695efb671">add_state</a> (const std::string &amp;key, HANDLE &amp;state, const std::string &amp;default_option, const std::vector&lt; std::string &gt; option_list)</td></tr>
<tr class="memdesc:a2a6850c97f206e6302d94b7695efb671 inherit pub_methods_class_core_1_1_state_handler"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add a local state variable with option list. <br /></td></tr>
<tr class="separator:a2a6850c97f206e6302d94b7695efb671 inherit pub_methods_class_core_1_1_state_handler"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3ec3f399c0825834c18aae8da71faa71 inherit pub_methods_class_core_1_1_state_handler"><td class="memTemplParams" colspan="2"><a class="anchor" id="a3ec3f399c0825834c18aae8da71faa71"></a>
template&lt;class HANDLE &gt; </td></tr>
<tr class="memitem:a3ec3f399c0825834c18aae8da71faa71 inherit pub_methods_class_core_1_1_state_handler"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_core_1_1_state_handler.html#a3ec3f399c0825834c18aae8da71faa71">add_state</a> (const std::string &amp;key, HANDLE &amp;state, const std::string &amp;default_option, const std::vector&lt; OptionLabelPair &gt; option_list)</td></tr>
<tr class="memdesc:a3ec3f399c0825834c18aae8da71faa71 inherit pub_methods_class_core_1_1_state_handler"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add a local state variable with option list. <br /></td></tr>
<tr class="separator:a3ec3f399c0825834c18aae8da71faa71 inherit pub_methods_class_core_1_1_state_handler"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aec1a25f20c04bbcd648b447be923bd9d inherit pub_methods_class_core_1_1_state_handler"><td class="memTemplParams" colspan="2"><a class="anchor" id="aec1a25f20c04bbcd648b447be923bd9d"></a>
template&lt;class HANDLE &gt; </td></tr>
<tr class="memitem:aec1a25f20c04bbcd648b447be923bd9d inherit pub_methods_class_core_1_1_state_handler"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_core_1_1_state_handler.html#aec1a25f20c04bbcd648b447be923bd9d">add_state</a> (const std::string &amp;key, HANDLE &amp;state, const std::vector&lt; std::string &gt; &amp;default_options, const std::vector&lt; OptionLabelPair &gt; option_list)</td></tr>
<tr class="memdesc:aec1a25f20c04bbcd648b447be923bd9d inherit pub_methods_class_core_1_1_state_handler"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add a local state variable with option list. <br /></td></tr>
<tr class="separator:aec1a25f20c04bbcd648b447be923bd9d inherit pub_methods_class_core_1_1_state_handler"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a828fce9ba5be14460db0520c8e3f2112 inherit pub_methods_class_core_1_1_state_handler"><td class="memTemplParams" colspan="2"><a class="anchor" id="a828fce9ba5be14460db0520c8e3f2112"></a>
template&lt;class HANDLE &gt; </td></tr>
<tr class="memitem:a828fce9ba5be14460db0520c8e3f2112 inherit pub_methods_class_core_1_1_state_handler"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_core_1_1_state_handler.html#a828fce9ba5be14460db0520c8e3f2112">add_state</a> (const std::string &amp;key, HANDLE &amp;state, const std::vector&lt; std::string &gt; &amp;default_options, const std::string &amp;option_list)</td></tr>
<tr class="memdesc:a828fce9ba5be14460db0520c8e3f2112 inherit pub_methods_class_core_1_1_state_handler"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add a local state variable with option list. <br /></td></tr>
<tr class="separator:a828fce9ba5be14460db0520c8e3f2112 inherit pub_methods_class_core_1_1_state_handler"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a91e50bbe7372f4b1e0c7e8c2770e2bb0 inherit pub_methods_class_core_1_1_state_handler"><td class="memTemplParams" colspan="2"><a class="anchor" id="a91e50bbe7372f4b1e0c7e8c2770e2bb0"></a>
template&lt;class HANDLE , class T &gt; </td></tr>
<tr class="memitem:a91e50bbe7372f4b1e0c7e8c2770e2bb0 inherit pub_methods_class_core_1_1_state_handler"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_core_1_1_state_handler.html#a91e50bbe7372f4b1e0c7e8c2770e2bb0">add_state</a> (const std::string &amp;key, HANDLE &amp;state, const std::vector&lt; T &gt; &amp;default_value)</td></tr>
<tr class="memdesc:a91e50bbe7372f4b1e0c7e8c2770e2bb0 inherit pub_methods_class_core_1_1_state_handler"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add a local state variable without default value. <br /></td></tr>
<tr class="separator:a91e50bbe7372f4b1e0c7e8c2770e2bb0 inherit pub_methods_class_core_1_1_state_handler"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab012962e27e7c48cf3b3f7caefe5d040 inherit pub_methods_class_core_1_1_state_handler"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_core_1_1_state_handler.html#ab012962e27e7c48cf3b3f7caefe5d040">invalidate</a> ()</td></tr>
<tr class="memdesc:ab012962e27e7c48cf3b3f7caefe5d040 inherit pub_methods_class_core_1_1_state_handler"><td class="mdescLeft">&#160;</td><td class="mdescRight">this function is called when you need to delete something from the state engine, but may have  <a href="#ab012962e27e7c48cf3b3f7caefe5d040">More...</a><br /></td></tr>
<tr class="separator:ab012962e27e7c48cf3b3f7caefe5d040 inherit pub_methods_class_core_1_1_state_handler"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a486bf4a2478efa1164d7434415e054f2 inherit pub_methods_class_core_1_1_state_handler"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a486bf4a2478efa1164d7434415e054f2"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_core_1_1_state_handler.html#a486bf4a2478efa1164d7434415e054f2">is_valid</a> ()</td></tr>
<tr class="memdesc:a486bf4a2478efa1164d7434415e054f2 inherit pub_methods_class_core_1_1_state_handler"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns true if the function hasn't been invalidated <br /></td></tr>
<tr class="separator:a486bf4a2478efa1164d7434415e054f2 inherit pub_methods_class_core_1_1_state_handler"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab0f6503ed95aa9b4b7a2983293920603 inherit pub_methods_class_core_1_1_state_handler"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab0f6503ed95aa9b4b7a2983293920603"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_core_1_1_state_handler.html#ab0f6503ed95aa9b4b7a2983293920603">mark_as_project_data</a> ()</td></tr>
<tr class="memdesc:ab0f6503ed95aa9b4b7a2983293920603 inherit pub_methods_class_core_1_1_state_handler"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mask the states that are added to this state handler as project data. <br /></td></tr>
<tr class="separator:ab0f6503ed95aa9b4b7a2983293920603 inherit pub_methods_class_core_1_1_state_handler"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab1598c00ae723262c99c2c134874236f inherit pub_methods_class_core_1_1_state_handler"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab1598c00ae723262c99c2c134874236f"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_core_1_1_state_handler.html#ab1598c00ae723262c99c2c134874236f">do_not_save_id_number</a> ()</td></tr>
<tr class="memdesc:ab1598c00ae723262c99c2c134874236f inherit pub_methods_class_core_1_1_state_handler"><td class="mdescLeft">&#160;</td><td class="mdescRight">The id number of the statehandler will not be saved. <br /></td></tr>
<tr class="separator:ab1598c00ae723262c99c2c134874236f inherit pub_methods_class_core_1_1_state_handler"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aea38460a79623a5079098aafce0c9ccd inherit pub_methods_class_core_1_1_state_handler"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_core_1_1_state_handler.html#aea38460a79623a5079098aafce0c9ccd">set_initializing</a> (bool initializing)</td></tr>
<tr class="separator:aea38460a79623a5079098aafce0c9ccd inherit pub_methods_class_core_1_1_state_handler"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3a1595bc8ab13ecf61b1fb3cf24329f3 inherit pub_methods_class_core_1_1_state_handler"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a3a1595bc8ab13ecf61b1fb3cf24329f3"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_core_1_1_state_handler.html#a3a1595bc8ab13ecf61b1fb3cf24329f3">load_states</a> (const <a class="el" href="class_core_1_1_state_i_o.html">StateIO</a> &amp;state_io)</td></tr>
<tr class="memdesc:a3a1595bc8ab13ecf61b1fb3cf24329f3 inherit pub_methods_class_core_1_1_state_handler"><td class="mdescLeft">&#160;</td><td class="mdescRight">Load the states into the <a class="el" href="class_core_1_1_state_i_o.html">StateIO</a> variable. <br /></td></tr>
<tr class="separator:a3a1595bc8ab13ecf61b1fb3cf24329f3 inherit pub_methods_class_core_1_1_state_handler"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af14923ceca390910a1f6d9676e611e84 inherit pub_methods_class_core_1_1_state_handler"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af14923ceca390910a1f6d9676e611e84"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_core_1_1_state_handler.html#af14923ceca390910a1f6d9676e611e84">save_states</a> (<a class="el" href="class_core_1_1_state_i_o.html">StateIO</a> &amp;state_io)</td></tr>
<tr class="memdesc:af14923ceca390910a1f6d9676e611e84 inherit pub_methods_class_core_1_1_state_handler"><td class="mdescLeft">&#160;</td><td class="mdescRight">Save the states into the <a class="el" href="class_core_1_1_state_i_o.html">StateIO</a> variable. <br /></td></tr>
<tr class="separator:af14923ceca390910a1f6d9676e611e84 inherit pub_methods_class_core_1_1_state_handler"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d89cd3bc09b1e90ec509f617f4c3250 inherit pub_methods_class_core_1_1_state_handler"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a9d89cd3bc09b1e90ec509f617f4c3250"></a>
const std::string &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_core_1_1_state_handler.html#a9d89cd3bc09b1e90ec509f617f4c3250">get_statehandler_id</a> () const </td></tr>
<tr class="memdesc:a9d89cd3bc09b1e90ec509f617f4c3250 inherit pub_methods_class_core_1_1_state_handler"><td class="mdescLeft">&#160;</td><td class="mdescRight">The id of the handler that will be the prefix of the state variables. <br /></td></tr>
<tr class="separator:a9d89cd3bc09b1e90ec509f617f4c3250 inherit pub_methods_class_core_1_1_state_handler"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa561f0186e64476f0cb09fb47d975e28 inherit pub_methods_class_core_1_1_state_handler"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa561f0186e64476f0cb09fb47d975e28"></a>
const std::string &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_core_1_1_state_handler.html#aa561f0186e64476f0cb09fb47d975e28">get_statehandler_id_base</a> () const </td></tr>
<tr class="memdesc:aa561f0186e64476f0cb09fb47d975e28 inherit pub_methods_class_core_1_1_state_handler"><td class="mdescLeft">&#160;</td><td class="mdescRight">The id of the handler that will be the prefix of the state variables. <br /></td></tr>
<tr class="separator:aa561f0186e64476f0cb09fb47d975e28 inherit pub_methods_class_core_1_1_state_handler"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9530d915f185ed22e708f0d3dd88a24e inherit pub_methods_class_core_1_1_state_handler"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a9530d915f185ed22e708f0d3dd88a24e"></a>
size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_core_1_1_state_handler.html#a9530d915f185ed22e708f0d3dd88a24e">get_statehandler_id_number</a> () const </td></tr>
<tr class="memdesc:a9530d915f185ed22e708f0d3dd88a24e inherit pub_methods_class_core_1_1_state_handler"><td class="mdescLeft">&#160;</td><td class="mdescRight">The id number of the handler that will be at the end of the prefix. <br /></td></tr>
<tr class="separator:a9530d915f185ed22e708f0d3dd88a24e inherit pub_methods_class_core_1_1_state_handler"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:a9f95472ca8a83d87b6ca3414bc23a1eb"><td class="memItemLeft" align="right" valign="top">static LayerHandle&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_seg3_d_1_1_layer_manager.html#a9f95472ca8a83d87b6ca3414bc23a1eb">FindLayer</a> (const std::string &amp;layer_id, SandboxID sandbox=-1)</td></tr>
<tr class="separator:a9f95472ca8a83d87b6ca3414bc23a1eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a737211decd5f7df6ae1304ccba5720ea"><td class="memItemLeft" align="right" valign="top">static LayerHandle&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_seg3_d_1_1_layer_manager.html#a737211decd5f7df6ae1304ccba5720ea">FindLayer</a> (ProvenanceID prov_id, SandboxID sandbox=-1)</td></tr>
<tr class="separator:a737211decd5f7df6ae1304ccba5720ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5fe479a5f23845f65e67a82efee00732"><td class="memItemLeft" align="right" valign="top">static LayerGroupHandle&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_seg3_d_1_1_layer_manager.html#a5fe479a5f23845f65e67a82efee00732">FindGroup</a> (const std::string &amp;group_id)</td></tr>
<tr class="separator:a5fe479a5f23845f65e67a82efee00732"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a56c1a4e0d6ff86145845833ad782adc5"><td class="memItemLeft" align="right" valign="top">static LayerGroupHandle&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_seg3_d_1_1_layer_manager.html#a56c1a4e0d6ff86145845833ad782adc5">FindGroup</a> (ProvenanceID prov_id)</td></tr>
<tr class="separator:a56c1a4e0d6ff86145845833ad782adc5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc4973c70d95e718b9008d2012628073"><td class="memItemLeft" align="right" valign="top">static MaskLayerHandle&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_seg3_d_1_1_layer_manager.html#adc4973c70d95e718b9008d2012628073">FindMaskLayer</a> (const std::string &amp;layer_id, SandboxID sandbox=-1)</td></tr>
<tr class="separator:adc4973c70d95e718b9008d2012628073"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7355882fd6db0ea7c248411457fe6184"><td class="memItemLeft" align="right" valign="top">static DataLayerHandle&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_seg3_d_1_1_layer_manager.html#a7355882fd6db0ea7c248411457fe6184">FindDataLayer</a> (const std::string &amp;layer_id, SandboxID sandbox=-1)</td></tr>
<tr class="separator:a7355882fd6db0ea7c248411457fe6184"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abd0714e99a06d2661b122c9c1bf4a2fc"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_seg3_d_1_1_layer_manager.html#abd0714e99a06d2661b122c9c1bf4a2fc">CheckGroupExistence</a> (const std::string &amp;layer_id, std::string &amp;error)</td></tr>
<tr class="separator:abd0714e99a06d2661b122c9c1bf4a2fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aafe0a13849b188e6daabf09d1d3e910e"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_seg3_d_1_1_layer_manager.html#aafe0a13849b188e6daabf09d1d3e910e">CheckSandboxExistence</a> (SandboxID sandbox, Core::ActionContextHandle context)</td></tr>
<tr class="separator:aafe0a13849b188e6daabf09d1d3e910e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a05a80bc73c19aad89860406345b3b733"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_seg3_d_1_1_layer_manager.html#a05a80bc73c19aad89860406345b3b733">CheckLayerExistence</a> (const std::string &amp;layer_id, Core::ActionContextHandle context, SandboxID sandbox=-1)</td></tr>
<tr class="separator:a05a80bc73c19aad89860406345b3b733"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a56c8ca57a178e5d07a82cb7184871d0a"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_seg3_d_1_1_layer_manager.html#a56c8ca57a178e5d07a82cb7184871d0a">CheckLayerExistence</a> (const std::string &amp;layer_id, SandboxID sandbox=-1)</td></tr>
<tr class="separator:a56c8ca57a178e5d07a82cb7184871d0a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa7579b4f6397a56b6f00c24713523b3c"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_seg3_d_1_1_layer_manager.html#aa7579b4f6397a56b6f00c24713523b3c">CheckLayerExistenceAndType</a> (const std::string &amp;layer_id, Core::VolumeType type, Core::ActionContextHandle context, SandboxID sandbox=-1)</td></tr>
<tr class="separator:aa7579b4f6397a56b6f00c24713523b3c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f107644b0686b27e39596c8d1e941c2"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_seg3_d_1_1_layer_manager.html#a1f107644b0686b27e39596c8d1e941c2">CheckLayerSize</a> (const std::string &amp;layer_id1, const std::string &amp;layer_id2, Core::ActionContextHandle context, SandboxID sandbox=-1)</td></tr>
<tr class="separator:a1f107644b0686b27e39596c8d1e941c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a248ee5176ab953b1634cdad4e18d8ce7"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_seg3_d_1_1_layer_manager.html#a248ee5176ab953b1634cdad4e18d8ce7">CheckLayerAvailabilityForProcessing</a> (const std::string &amp;layer_id, Core::ActionContextHandle context, SandboxID sandbox=-1)</td></tr>
<tr class="separator:a248ee5176ab953b1634cdad4e18d8ce7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abe151c445734bdb9931c61af91a06817"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_seg3_d_1_1_layer_manager.html#abe151c445734bdb9931c61af91a06817">CheckLayerAvailabilityForUse</a> (const std::string &amp;layer_id, Core::ActionContextHandle context, SandboxID sandbox=-1)</td></tr>
<tr class="separator:abe151c445734bdb9931c61af91a06817"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a04ae7128a872d6613b93ae6871a1eb6b"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_seg3_d_1_1_layer_manager.html#a04ae7128a872d6613b93ae6871a1eb6b">CheckLayerAvailability</a> (const std::string &amp;layer_id, bool replace, Core::ActionContextHandle context, SandboxID sandbox=-1)</td></tr>
<tr class="separator:a04ae7128a872d6613b93ae6871a1eb6b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aab662b45423f8707db52bb2db4912e7f"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_seg3_d_1_1_layer_manager.html#aab662b45423f8707db52bb2db4912e7f">LockForUse</a> (LayerHandle layer, <a class="el" href="class_seg3_d_1_1_layer_manager.html#af5b4b2b6539f8fbde47c9edcae1f866f">filter_key_type</a> key=<a class="el" href="class_seg3_d_1_1_layer_manager.html#af5b4b2b6539f8fbde47c9edcae1f866f">filter_key_type</a>(0))</td></tr>
<tr class="separator:aab662b45423f8707db52bb2db4912e7f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae01ae8778f0373920984a90349c2c7d9"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_seg3_d_1_1_layer_manager.html#ae01ae8778f0373920984a90349c2c7d9">LockForProcessing</a> (LayerHandle layer, <a class="el" href="class_seg3_d_1_1_layer_manager.html#af5b4b2b6539f8fbde47c9edcae1f866f">filter_key_type</a> key=<a class="el" href="class_seg3_d_1_1_layer_manager.html#af5b4b2b6539f8fbde47c9edcae1f866f">filter_key_type</a>(0))</td></tr>
<tr class="separator:ae01ae8778f0373920984a90349c2c7d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab935c19fac3f21a85af7c7912ecb1937"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_seg3_d_1_1_layer_manager.html#ab935c19fac3f21a85af7c7912ecb1937">CreateAndLockMaskLayer</a> (<a class="el" href="class_core_1_1_grid_transform.html">Core::GridTransform</a> transform, const std::string &amp;name, LayerHandle &amp;layer, const <a class="el" href="class_seg3_d_1_1_layer_meta_data.html">LayerMetaData</a> &amp;meta_data, <a class="el" href="class_seg3_d_1_1_layer_manager.html#af5b4b2b6539f8fbde47c9edcae1f866f">filter_key_type</a> key=<a class="el" href="class_seg3_d_1_1_layer_manager.html#af5b4b2b6539f8fbde47c9edcae1f866f">filter_key_type</a>(0), SandboxID sandbox=-1)</td></tr>
<tr class="separator:ab935c19fac3f21a85af7c7912ecb1937"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d220e1ee5724c5b03bcd6b315fcbffe"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_seg3_d_1_1_layer_manager.html#a0d220e1ee5724c5b03bcd6b315fcbffe">CreateAndLockDataLayer</a> (<a class="el" href="class_core_1_1_grid_transform.html">Core::GridTransform</a>, const std::string &amp;name, LayerHandle &amp;layer, const <a class="el" href="class_seg3_d_1_1_layer_meta_data.html">LayerMetaData</a> &amp;meta_data, <a class="el" href="class_seg3_d_1_1_layer_manager.html#af5b4b2b6539f8fbde47c9edcae1f866f">filter_key_type</a> key=<a class="el" href="class_seg3_d_1_1_layer_manager.html#af5b4b2b6539f8fbde47c9edcae1f866f">filter_key_type</a>(0), SandboxID sandbox=-1)</td></tr>
<tr class="separator:a0d220e1ee5724c5b03bcd6b315fcbffe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1419e15bd606ea3a0bc0c9e72025eddf"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_seg3_d_1_1_layer_manager.html#a1419e15bd606ea3a0bc0c9e72025eddf">CreateCroppedLargeVolumeLayer</a> (Core::LargeVolumeSchemaHandle schema, const <a class="el" href="class_core_1_1_grid_transform.html">Core::GridTransform</a> &amp;crop_trans, const std::string &amp;name, LayerHandle &amp;layer, const <a class="el" href="class_seg3_d_1_1_layer_meta_data.html">LayerMetaData</a> &amp;meta_data, SandboxID sandbox=-1)</td></tr>
<tr class="separator:a1419e15bd606ea3a0bc0c9e72025eddf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0f30c636cf1a4eb3f806c5876b00e431"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_seg3_d_1_1_layer_manager.html#a0f30c636cf1a4eb3f806c5876b00e431">DispatchUnlockLayer</a> (LayerHandle layer, <a class="el" href="class_seg3_d_1_1_layer_manager.html#af5b4b2b6539f8fbde47c9edcae1f866f">filter_key_type</a> key=<a class="el" href="class_seg3_d_1_1_layer_manager.html#af5b4b2b6539f8fbde47c9edcae1f866f">filter_key_type</a>(0), SandboxID sandbox=-1)</td></tr>
<tr class="separator:a0f30c636cf1a4eb3f806c5876b00e431"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1083cc4708db8a263bee0b9bb7332d96"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_seg3_d_1_1_layer_manager.html#a1083cc4708db8a263bee0b9bb7332d96">DispatchDeleteLayer</a> (LayerHandle layer, <a class="el" href="class_seg3_d_1_1_layer_manager.html#af5b4b2b6539f8fbde47c9edcae1f866f">filter_key_type</a> key=<a class="el" href="class_seg3_d_1_1_layer_manager.html#af5b4b2b6539f8fbde47c9edcae1f866f">filter_key_type</a>(0), SandboxID sandbox=-1)</td></tr>
<tr class="separator:a1083cc4708db8a263bee0b9bb7332d96"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a74a5b6f5055c5904925eea2a2a619084"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_seg3_d_1_1_layer_manager.html#a74a5b6f5055c5904925eea2a2a619084">DispatchUnlockOrDeleteLayer</a> (LayerHandle layer, <a class="el" href="class_seg3_d_1_1_layer_manager.html#af5b4b2b6539f8fbde47c9edcae1f866f">filter_key_type</a> key=<a class="el" href="class_seg3_d_1_1_layer_manager.html#af5b4b2b6539f8fbde47c9edcae1f866f">filter_key_type</a>(0), SandboxID sandbox=-1)</td></tr>
<tr class="separator:a74a5b6f5055c5904925eea2a2a619084"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad19a669adb7aa27218a1c5f06ceb593b"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_seg3_d_1_1_layer_manager.html#ad19a669adb7aa27218a1c5f06ceb593b">DispatchInsertDataVolumeIntoLayer</a> (DataLayerHandle layer, Core::DataVolumeHandle data, ProvenanceID provid, <a class="el" href="class_seg3_d_1_1_layer_manager.html#af5b4b2b6539f8fbde47c9edcae1f866f">filter_key_type</a> key=<a class="el" href="class_seg3_d_1_1_layer_manager.html#af5b4b2b6539f8fbde47c9edcae1f866f">filter_key_type</a>(0), SandboxID sandbox=-1)</td></tr>
<tr class="separator:ad19a669adb7aa27218a1c5f06ceb593b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a198e32c55970213d7d9f19b43253547a"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_seg3_d_1_1_layer_manager.html#a198e32c55970213d7d9f19b43253547a">DispatchInsertMaskVolumeIntoLayer</a> (MaskLayerHandle layer, Core::MaskVolumeHandle mask, ProvenanceID provid, <a class="el" href="class_seg3_d_1_1_layer_manager.html#af5b4b2b6539f8fbde47c9edcae1f866f">filter_key_type</a> key=<a class="el" href="class_seg3_d_1_1_layer_manager.html#af5b4b2b6539f8fbde47c9edcae1f866f">filter_key_type</a>(0), SandboxID sandbox=-1)</td></tr>
<tr class="separator:a198e32c55970213d7d9f19b43253547a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5b805765b4765a8b2f410b4c57bc194a"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_seg3_d_1_1_layer_manager.html#a5b805765b4765a8b2f410b4c57bc194a">DispatchInsertVolumeIntoLayer</a> (LayerHandle layer, Core::VolumeHandle mask, ProvenanceID provid, <a class="el" href="class_seg3_d_1_1_layer_manager.html#af5b4b2b6539f8fbde47c9edcae1f866f">filter_key_type</a> key=<a class="el" href="class_seg3_d_1_1_layer_manager.html#af5b4b2b6539f8fbde47c9edcae1f866f">filter_key_type</a>(0), SandboxID sandbox=-1)</td></tr>
<tr class="separator:a5b805765b4765a8b2f410b4c57bc194a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa8dd5c05e9c17784da10356313e79f49"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_seg3_d_1_1_layer_manager.html#aa8dd5c05e9c17784da10356313e79f49">DispatchInsertDataSliceIntoLayer</a> (DataLayerHandle layer, Core::DataSliceHandle data, ProvenanceID provid, <a class="el" href="class_seg3_d_1_1_layer_manager.html#af5b4b2b6539f8fbde47c9edcae1f866f">filter_key_type</a> key=<a class="el" href="class_seg3_d_1_1_layer_manager.html#af5b4b2b6539f8fbde47c9edcae1f866f">filter_key_type</a>(0), SandboxID sandbox=-1)</td></tr>
<tr class="separator:aa8dd5c05e9c17784da10356313e79f49"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad874c5313e7d78a152d43c9001cccfd4"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_seg3_d_1_1_layer_manager.html#ad874c5313e7d78a152d43c9001cccfd4">DispatchInsertDataSlicesIntoLayer</a> (DataLayerHandle layer, std::vector&lt; Core::DataSliceHandle &gt; data, ProvenanceID provid, <a class="el" href="class_seg3_d_1_1_layer_manager.html#af5b4b2b6539f8fbde47c9edcae1f866f">filter_key_type</a> key=<a class="el" href="class_seg3_d_1_1_layer_manager.html#af5b4b2b6539f8fbde47c9edcae1f866f">filter_key_type</a>(0), SandboxID sandbox=-1)</td></tr>
<tr class="separator:ad874c5313e7d78a152d43c9001cccfd4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0254b8a63ad97be40c5a95e95e74f450"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_seg3_d_1_1_layer_manager.html#a0254b8a63ad97be40c5a95e95e74f450">DispatchInsertMaskSliceIntoLayer</a> (MaskLayerHandle layer, Core::MaskDataSliceHandle mask, ProvenanceID provid, <a class="el" href="class_seg3_d_1_1_layer_manager.html#af5b4b2b6539f8fbde47c9edcae1f866f">filter_key_type</a> key=<a class="el" href="class_seg3_d_1_1_layer_manager.html#af5b4b2b6539f8fbde47c9edcae1f866f">filter_key_type</a>(0), SandboxID sandbox=-1)</td></tr>
<tr class="separator:a0254b8a63ad97be40c5a95e95e74f450"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad28b4bb11538b215c28084145493c792"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_seg3_d_1_1_layer_manager.html#ad28b4bb11538b215c28084145493c792">DispatchInsertMaskSlicesIntoLayer</a> (MaskLayerHandle layer, std::vector&lt; Core::MaskDataSliceHandle &gt; mask, ProvenanceID provid, <a class="el" href="class_seg3_d_1_1_layer_manager.html#af5b4b2b6539f8fbde47c9edcae1f866f">filter_key_type</a> key=<a class="el" href="class_seg3_d_1_1_layer_manager.html#af5b4b2b6539f8fbde47c9edcae1f866f">filter_key_type</a>(0), SandboxID sandbox=-1)</td></tr>
<tr class="separator:ad28b4bb11538b215c28084145493c792"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0435095575132821b55639e4b9df1299"><td class="memItemLeft" align="right" valign="top">static id_count_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_seg3_d_1_1_layer_manager.html#a0435095575132821b55639e4b9df1299">GetLayerIdCount</a> ()</td></tr>
<tr class="separator:a0435095575132821b55639e4b9df1299"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a19a3f8c4d8f81cc84df6472323f7bede"><td class="memItemLeft" align="right" valign="top">static id_count_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_seg3_d_1_1_layer_manager.html#a19a3f8c4d8f81cc84df6472323f7bede">GetLayerInvalidIdCount</a> ()</td></tr>
<tr class="separator:a19a3f8c4d8f81cc84df6472323f7bede"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af11d24bcd84655b75f5b6f0a2d5290bd"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_seg3_d_1_1_layer_manager.html#af11d24bcd84655b75f5b6f0a2d5290bd">SetLayerIdCount</a> (id_count_type id_count)</td></tr>
<tr class="separator:af11d24bcd84655b75f5b6f0a2d5290bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-attribs"></a>
Public Attributes</h2></td></tr>
<tr class="memitem:ac32269274fad79f690a2cd194e69d76c"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac32269274fad79f690a2cd194e69d76c"></a>
Core::StateLabeledOptionHandle&#160;</td><td class="memItemRight" valign="bottom"><b>active_layer_state_</b></td></tr>
<tr class="separator:ac32269274fad79f690a2cd194e69d76c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abe84f7e3d5c8ffbc806996a27301f08b"><td class="memItemLeft" align="right" valign="top">boost::signals2::signal&lt; void(LayerHandle, bool) &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_seg3_d_1_1_layer_manager.html#abe84f7e3d5c8ffbc806996a27301f08b">layer_inserted_signal_</a></td></tr>
<tr class="separator:abe84f7e3d5c8ffbc806996a27301f08b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a092d66815f1810362a57d814b9384244"><td class="memItemLeft" align="right" valign="top">boost::signals2::signal&lt; void(std::vector&lt; std::string &gt;, std::vector&lt; std::string &gt;, bool) &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_seg3_d_1_1_layer_manager.html#a092d66815f1810362a57d814b9384244">layers_deleted_signal_</a></td></tr>
<tr class="separator:a092d66815f1810362a57d814b9384244"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a98d52c7359223e1d685a35a9e01b35f9"><td class="memItemLeft" align="right" valign="top">boost::signals2::signal&lt; void(std::string) &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_seg3_d_1_1_layer_manager.html#a98d52c7359223e1d685a35a9e01b35f9">layers_reordered_signal_</a></td></tr>
<tr class="separator:a98d52c7359223e1d685a35a9e01b35f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abfebeda58b3618734084dd98793c1fc1"><td class="memItemLeft" align="right" valign="top">boost::signals2::signal&lt; void() &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_seg3_d_1_1_layer_manager.html#abfebeda58b3618734084dd98793c1fc1">groups_reordered_signal_</a></td></tr>
<tr class="separator:abfebeda58b3618734084dd98793c1fc1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a81266b692030472bae858897b7cffb3b"><td class="memItemLeft" align="right" valign="top">boost::signals2::signal&lt; void() &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_seg3_d_1_1_layer_manager.html#a81266b692030472bae858897b7cffb3b">layers_changed_signal_</a></td></tr>
<tr class="separator:a81266b692030472bae858897b7cffb3b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6bbe024f1636477fadb115321bcc79bb"><td class="memItemLeft" align="right" valign="top">boost::signals2::signal&lt; void() &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_seg3_d_1_1_layer_manager.html#a6bbe024f1636477fadb115321bcc79bb">mask_layer_isosurface_created_signal_</a></td></tr>
<tr class="separator:a6bbe024f1636477fadb115321bcc79bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa3bd8519296a6bafb3f0fd491c19cf56"><td class="memItemLeft" align="right" valign="top">boost::signals2::signal&lt; void() &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_seg3_d_1_1_layer_manager.html#aa3bd8519296a6bafb3f0fd491c19cf56">mask_layer_isosurface_deleted_signal_</a></td></tr>
<tr class="separator:aa3bd8519296a6bafb3f0fd491c19cf56"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:add6bfaf895747a838ced64b78eb2580f"><td class="memItemLeft" align="right" valign="top">boost::signals2::signal&lt; void(LayerHandle) &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_seg3_d_1_1_layer_manager.html#add6bfaf895747a838ced64b78eb2580f">active_layer_changed_signal_</a></td></tr>
<tr class="separator:add6bfaf895747a838ced64b78eb2580f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3e1c3977cd80f14ccfeba0dd6d597cd6"><td class="memItemLeft" align="right" valign="top">boost::signals2::signal&lt; void(std::string, std::string) &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_seg3_d_1_1_layer_manager.html#a3e1c3977cd80f14ccfeba0dd6d597cd6">layer_name_changed_signal_</a></td></tr>
<tr class="separator:a3e1c3977cd80f14ccfeba0dd6d597cd6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a94428982c6e0c64ce461b73f77e8eed9"><td class="memItemLeft" align="right" valign="top">boost::signals2::signal&lt; void(LayerHandle) &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_seg3_d_1_1_layer_manager.html#a94428982c6e0c64ce461b73f77e8eed9">layer_volume_changed_signal_</a></td></tr>
<tr class="separator:a94428982c6e0c64ce461b73f77e8eed9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a18bbc7c07d7b9056f1d3fbc8bfffeecd"><td class="memItemLeft" align="right" valign="top">boost::signals2::signal&lt; void(LayerHandle) &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_seg3_d_1_1_layer_manager.html#a18bbc7c07d7b9056f1d3fbc8bfffeecd">layer_data_changed_signal_</a></td></tr>
<tr class="separator:a18bbc7c07d7b9056f1d3fbc8bfffeecd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afab232acf3826d088e78d0f67cf998a0"><td class="memItemLeft" align="right" valign="top">boost::signals2::signal&lt; void(SandboxID) &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_seg3_d_1_1_layer_manager.html#afab232acf3826d088e78d0f67cf998a0">sandbox_created_signal_</a></td></tr>
<tr class="separator:afab232acf3826d088e78d0f67cf998a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9564ddf6ce3cf9c6e624b083a40b2fef"><td class="memItemLeft" align="right" valign="top">boost::signals2::signal&lt; void(SandboxID) &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_seg3_d_1_1_layer_manager.html#a9564ddf6ce3cf9c6e624b083a40b2fef">sandbox_deleted_signal_</a></td></tr>
<tr class="separator:a9564ddf6ce3cf9c6e624b083a40b2fef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab128d108337ee5d844dc14f32aca9fd0"><td class="memItemLeft" align="right" valign="top">boost::signals2::signal&lt; void(SandboxID, std::string) &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_seg3_d_1_1_layer_manager.html#ab128d108337ee5d844dc14f32aca9fd0">script_begin_signal_</a></td></tr>
<tr class="separator:ab128d108337ee5d844dc14f32aca9fd0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a806f64f78e6264892f7780561ca8752a"><td class="memItemLeft" align="right" valign="top">boost::signals2::signal&lt; void(SandboxID) &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_seg3_d_1_1_layer_manager.html#a806f64f78e6264892f7780561ca8752a">script_end_signal_</a></td></tr>
<tr class="separator:a806f64f78e6264892f7780561ca8752a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a32674ca1b7d4f9431c0ab401e25b9b8c"><td class="memItemLeft" align="right" valign="top">boost::signals2::signal&lt; void(SandboxID, std::string, size_t, size_t) &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_seg3_d_1_1_layer_manager.html#a32674ca1b7d4f9431c0ab401e25b9b8c">script_progress_signal_</a></td></tr>
<tr class="separator:a32674ca1b7d4f9431c0ab401e25b9b8c"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:a175f6e5cee9f1b6418511da828fdc5fe"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_seg3_d_1_1_layer_manager.html#a175f6e5cee9f1b6418511da828fdc5fe">pre_save_states</a> (<a class="el" href="class_core_1_1_state_i_o.html">Core::StateIO</a> &amp;state_io)</td></tr>
<tr class="separator:a175f6e5cee9f1b6418511da828fdc5fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7a8dfca832b62ff0d923e32ae072707b"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_seg3_d_1_1_layer_manager.html#a7a8dfca832b62ff0d923e32ae072707b">post_save_states</a> (<a class="el" href="class_core_1_1_state_i_o.html">Core::StateIO</a> &amp;state_io)</td></tr>
<tr class="separator:a7a8dfca832b62ff0d923e32ae072707b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1658cca681b459e9664e5c84fe113e44"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_seg3_d_1_1_layer_manager.html#a1658cca681b459e9664e5c84fe113e44">post_load_states</a> (const <a class="el" href="class_core_1_1_state_i_o.html">Core::StateIO</a> &amp;state_io)</td></tr>
<tr class="separator:a1658cca681b459e9664e5c84fe113e44"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a64b80e5632ed80b27dff3b539f5adbf5"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_seg3_d_1_1_layer_manager.html#a64b80e5632ed80b27dff3b539f5adbf5">pre_load_states</a> (const <a class="el" href="class_core_1_1_state_i_o.html">Core::StateIO</a> &amp;state_io)</td></tr>
<tr class="separator:a64b80e5632ed80b27dff3b539f5adbf5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pro_methods_class_core_1_1_state_handler"><td colspan="2" onclick="javascript:toggleInherit('pro_methods_class_core_1_1_state_handler')"><img src="closed.png" alt="-"/>&#160;Protected Member Functions inherited from <a class="el" href="class_core_1_1_state_handler.html">Core::StateHandler</a></td></tr>
<tr class="memitem:a1da9571feb12f3cd0eaf29154730f06b inherit pro_methods_class_core_1_1_state_handler"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a1da9571feb12f3cd0eaf29154730f06b"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_core_1_1_state_handler.html#a1da9571feb12f3cd0eaf29154730f06b">clean_up</a> ()</td></tr>
<tr class="memdesc:a1da9571feb12f3cd0eaf29154730f06b inherit pro_methods_class_core_1_1_state_handler"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function is called by invalidate to clean up stuff in the statehandler subclasses. <br /></td></tr>
<tr class="separator:a1da9571feb12f3cd0eaf29154730f06b inherit pro_methods_class_core_1_1_state_handler"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa6d3a8449a7caa9176d8068fe51d9b45 inherit pro_methods_class_core_1_1_state_handler"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa6d3a8449a7caa9176d8068fe51d9b45"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_core_1_1_state_handler.html#aa6d3a8449a7caa9176d8068fe51d9b45">enable_signals</a> (bool enabled)</td></tr>
<tr class="memdesc:aa6d3a8449a7caa9176d8068fe51d9b45 inherit pro_methods_class_core_1_1_state_handler"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function enables/disables signals in the state variables. <br /></td></tr>
<tr class="separator:aa6d3a8449a7caa9176d8068fe51d9b45 inherit pro_methods_class_core_1_1_state_handler"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4297a6eaac2b64419174e6c4ecb0a445 inherit pro_methods_class_core_1_1_state_handler"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_core_1_1_state_handler.html#a4297a6eaac2b64419174e6c4ecb0a445">state_changed</a> ()</td></tr>
<tr class="separator:a4297a6eaac2b64419174e6c4ecb0a445 inherit pro_methods_class_core_1_1_state_handler"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afbb18039dcb6a9816e6a81b969ac4d5d inherit pro_methods_class_core_1_1_state_handler"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="afbb18039dcb6a9816e6a81b969ac4d5d"></a>
virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_core_1_1_state_handler.html#afbb18039dcb6a9816e6a81b969ac4d5d">get_version</a> ()</td></tr>
<tr class="memdesc:afbb18039dcb6a9816e6a81b969ac4d5d inherit pro_methods_class_core_1_1_state_handler"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the version number of this class, this one is used for versioning of session files. <br /></td></tr>
<tr class="separator:afbb18039dcb6a9816e6a81b969ac4d5d inherit pro_methods_class_core_1_1_state_handler"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae3087782498f2a18cb2c5622e385ba1a inherit pro_methods_class_core_1_1_state_handler"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae3087782498f2a18cb2c5622e385ba1a"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_core_1_1_state_handler.html#ae3087782498f2a18cb2c5622e385ba1a">get_loaded_version</a> ()</td></tr>
<tr class="memdesc:ae3087782498f2a18cb2c5622e385ba1a inherit pro_methods_class_core_1_1_state_handler"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the version number of the data that was loaded. <br /></td></tr>
<tr class="separator:ae3087782498f2a18cb2c5622e385ba1a inherit pro_methods_class_core_1_1_state_handler"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2560a2e3cd31990fe6d8ca5fdf57781a inherit pro_methods_class_core_1_1_state_handler"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a2560a2e3cd31990fe6d8ca5fdf57781a"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_core_1_1_state_handler.html#a2560a2e3cd31990fe6d8ca5fdf57781a">set_loaded_version</a> (int loaded_version)</td></tr>
<tr class="memdesc:a2560a2e3cd31990fe6d8ca5fdf57781a inherit pro_methods_class_core_1_1_state_handler"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the version number of the data that was loaded. <br /></td></tr>
<tr class="separator:a2560a2e3cd31990fe6d8ca5fdf57781a inherit pro_methods_class_core_1_1_state_handler"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pro_methods_class_core_1_1_connection_handler"><td colspan="2" onclick="javascript:toggleInherit('pro_methods_class_core_1_1_connection_handler')"><img src="closed.png" alt="-"/>&#160;Protected Member Functions inherited from <a class="el" href="class_core_1_1_connection_handler.html">Core::ConnectionHandler</a></td></tr>
<tr class="memitem:a8257d005fced9dcbc9d5c42174c97de7 inherit pro_methods_class_core_1_1_connection_handler"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_core_1_1_connection_handler.html#a8257d005fced9dcbc9d5c42174c97de7">add_connection</a> (const boost::signals2::connection &amp;connection)</td></tr>
<tr class="separator:a8257d005fced9dcbc9d5c42174c97de7 inherit pro_methods_class_core_1_1_connection_handler"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a048b1a18e802c9cef99a2145c63f5dd7 inherit pro_methods_class_core_1_1_connection_handler"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_core_1_1_connection_handler.html#a048b1a18e802c9cef99a2145c63f5dd7">add_connection</a> (const ConnectionHandlerConnectionHandle &amp;connection)</td></tr>
<tr class="separator:a048b1a18e802c9cef99a2145c63f5dd7 inherit pro_methods_class_core_1_1_connection_handler"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8df9220658b66aab64fc3be3fdf06e2f inherit pro_methods_class_core_1_1_connection_handler"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_core_1_1_connection_handler.html#a8df9220658b66aab64fc3be3fdf06e2f">disconnect_all</a> ()</td></tr>
<tr class="separator:a8df9220658b66aab64fc3be3fdf06e2f inherit pro_methods_class_core_1_1_connection_handler"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="friends"></a>
Friends</h2></td></tr>
<tr class="memitem:a8c77c74ab7dfd614b51a9d90c0e04d56"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a8c77c74ab7dfd614b51a9d90c0e04d56"></a>
class&#160;</td><td class="memItemRight" valign="bottom"><b>ActionImportLargeVolumeLayer</b></td></tr>
<tr class="separator:a8c77c74ab7dfd614b51a9d90c0e04d56"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afb55b4fb22022285c891670090d69b97"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="afb55b4fb22022285c891670090d69b97"></a>
class&#160;</td><td class="memItemRight" valign="bottom"><b>ActionImportLayer</b></td></tr>
<tr class="separator:afb55b4fb22022285c891670090d69b97"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d2351f60581062329b87bbc2774bb4b"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a0d2351f60581062329b87bbc2774bb4b"></a>
class&#160;</td><td class="memItemRight" valign="bottom"><b>ActionImportSeries</b></td></tr>
<tr class="separator:a0d2351f60581062329b87bbc2774bb4b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af8bf55328b0af98c0c4112b7ee697dd0"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af8bf55328b0af98c0c4112b7ee697dd0"></a>
class&#160;</td><td class="memItemRight" valign="bottom"><b>ActionNewMaskLayer</b></td></tr>
<tr class="separator:af8bf55328b0af98c0c4112b7ee697dd0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af8b5db81496ba682a0d4e7500d600031"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af8b5db81496ba682a0d4e7500d600031"></a>
class&#160;</td><td class="memItemRight" valign="bottom"><b>ActionDuplicateLayer</b></td></tr>
<tr class="separator:af8b5db81496ba682a0d4e7500d600031"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a409fdac2f20a131c7b1ff65a84c57df2"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a409fdac2f20a131c7b1ff65a84c57df2"></a>
class&#160;</td><td class="memItemRight" valign="bottom"><b>ActionMoveLayer</b></td></tr>
<tr class="separator:a409fdac2f20a131c7b1ff65a84c57df2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a385b83fd99b5886fc8acd920f04908d2"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a385b83fd99b5886fc8acd920f04908d2"></a>
class&#160;</td><td class="memItemRight" valign="bottom"><b>ActionDeleteLayers</b></td></tr>
<tr class="separator:a385b83fd99b5886fc8acd920f04908d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa6049ef30d7332712a2591889ecd5ad9"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa6049ef30d7332712a2591889ecd5ad9"></a>
class&#160;</td><td class="memItemRight" valign="bottom"><b>ActionShiftActiveLayer</b></td></tr>
<tr class="separator:aa6049ef30d7332712a2591889ecd5ad9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac10c4954320d16e8b58f64bfa907d1c3"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac10c4954320d16e8b58f64bfa907d1c3"></a>
class&#160;</td><td class="memItemRight" valign="bottom"><b>ActionActivateLayer</b></td></tr>
<tr class="separator:ac10c4954320d16e8b58f64bfa907d1c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad88ff05fe123ea0dc2998a928e759a5b"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad88ff05fe123ea0dc2998a928e759a5b"></a>
class&#160;</td><td class="memItemRight" valign="bottom"><b>ActionMoveGroup</b></td></tr>
<tr class="separator:ad88ff05fe123ea0dc2998a928e759a5b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af311094d7abd3906a54e942cc48dca79"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af311094d7abd3906a54e942cc48dca79"></a>
class&#160;</td><td class="memItemRight" valign="bottom"><b>ActionCreateSandbox</b></td></tr>
<tr class="separator:af311094d7abd3906a54e942cc48dca79"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7728c15f85d0bb37b3d32ed2371d53fa"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a7728c15f85d0bb37b3d32ed2371d53fa"></a>
class&#160;</td><td class="memItemRight" valign="bottom"><b>ActionDeleteSandbox</b></td></tr>
<tr class="separator:a7728c15f85d0bb37b3d32ed2371d53fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa2721c01926ec9cd06e5faf2d1e0a35d"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa2721c01926ec9cd06e5faf2d1e0a35d"></a>
class&#160;</td><td class="memItemRight" valign="bottom"><b>ActionCopyLayerIntoSandbox</b></td></tr>
<tr class="separator:aa2721c01926ec9cd06e5faf2d1e0a35d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad8ebd0a8a75b6a86a4ebe4fbdf907633"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad8ebd0a8a75b6a86a4ebe4fbdf907633"></a>
class&#160;</td><td class="memItemRight" valign="bottom"><b>ActionMigrateSandboxLayer</b></td></tr>
<tr class="separator:ad8ebd0a8a75b6a86a4ebe4fbdf907633"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a317d7c32d8f33fa1d54b43bb0499821e"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a317d7c32d8f33fa1d54b43bb0499821e"></a>
class&#160;</td><td class="memItemRight" valign="bottom"><b>ActionRecreateLayer</b></td></tr>
<tr class="separator:a317d7c32d8f33fa1d54b43bb0499821e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a57d2e45ffb3019b0c067510b5a68ab4a"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a57d2e45ffb3019b0c067510b5a68ab4a"></a>
class&#160;</td><td class="memItemRight" valign="bottom"><b>LayerUndoBufferItem</b></td></tr>
<tr class="separator:a57d2e45ffb3019b0c067510b5a68ab4a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf2d19a1daed901d4e26f0ff1d55ed4e"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="acf2d19a1daed901d4e26f0ff1d55ed4e"></a>
class&#160;</td><td class="memItemRight" valign="bottom"><b>LayerRecreationUndoBufferItem</b></td></tr>
<tr class="separator:acf2d19a1daed901d4e26f0ff1d55ed4e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a58b5c68dafd44bc7a5952e8a60bd9473"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a58b5c68dafd44bc7a5952e8a60bd9473"></a>
class&#160;</td><td class="memItemRight" valign="bottom"><b>LayerManagerPrivate</b></td></tr>
<tr class="separator:a58b5c68dafd44bc7a5952e8a60bd9473"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Member Typedef Documentation</h2>
<a class="anchor" id="af5b4b2b6539f8fbde47c9edcae1f866f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="class_seg3_d_1_1_layer.html#abc913cc3a6cbf41f89d25fc7dca1991a">Layer::filter_key_type</a> <a class="el" href="class_seg3_d_1_1_layer_manager.html#af5b4b2b6539f8fbde47c9edcae1f866f">Seg3D::LayerManager::filter_key_type</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>KEY_TYPE: When locking a layer a key is returned. This key keeps track of the asynchronous process and is needed to reinsert a volume into layer. The purpose of the key is to ensure that a volume is only inserted by the asynchronous process if the key matches the one generated when the layer was locked. </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="abd0714e99a06d2661b122c9c1bf4a2fc"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Seg3D::LayerManager::CheckGroupExistence </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>layer_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string &amp;&#160;</td>
          <td class="paramname"><em>error</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>CHECKGROUPEXISTENCE: Check whether a group exists. If it does not exist, the function returns false and an error is string is returned. TODO: Need to make this one obsolete for provenance reasons everything will have to be done with layerid lists &ndash;JGS </p>

</div>
</div>
<a class="anchor" id="a04ae7128a872d6613b93ae6871a1eb6b"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Seg3D::LayerManager::CheckLayerAvailability </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>layer_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>replace</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Core::ActionContextHandle&#160;</td>
          <td class="paramname"><em>context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SandboxID&#160;</td>
          <td class="paramname"><em>sandbox</em> = <code>-1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>CHECKLAYERAVAILABILITY: Check whether a layer is available for use. This case processes both of the above cases: if replace is true, it will check for processing (write) access, if it is not replaced, it will look for use (read) access If a layer is not available a notifier is returned that tells can be used to assess when to check for availability again. Even though the notifier may return another process may have grabbed it in the mean time. In that case a new notifier will need to be issued by rechecking availability. NOTE: Availability needs to be tested to ensure that another process is not working on this this layer. </p>

</div>
</div>
<a class="anchor" id="a248ee5176ab953b1634cdad4e18d8ce7"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Seg3D::LayerManager::CheckLayerAvailabilityForProcessing </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>layer_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Core::ActionContextHandle&#160;</td>
          <td class="paramname"><em>context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SandboxID&#160;</td>
          <td class="paramname"><em>sandbox</em> = <code>-1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>CHECKLAYERAVAILABILITYFORPROCESSING: Check whether a layer is available for processing, at the end of the filter the data will be replaced with new data. Hence this is write access. If a layer is not available a notifier is returned that tells can be used to assess when to check for availability again. Even though the notifier may return another process may have grabbed it in the mean time. In that case a new notifier will need to be issued by rechecking availability. NOTE: Availability needs to be tested to ensure that another process is not working on this this layer. </p>

</div>
</div>
<a class="anchor" id="abe151c445734bdb9931c61af91a06817"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Seg3D::LayerManager::CheckLayerAvailabilityForUse </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>layer_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Core::ActionContextHandle&#160;</td>
          <td class="paramname"><em>context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SandboxID&#160;</td>
          <td class="paramname"><em>sandbox</em> = <code>-1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>CHECKLAYERAVAILABILITYFORUSE: Check whether a layer is available for use, i.e. data is not changed but needs to remain unchanged during the process. Hence this is read access If a layer is not available a notifier is returned that tells can be used to assess when to check for availability again. Even though the notifier may return another process may have grabbed it in the mean time. In that case a new notifier will need to be issued by rechecking availability. NOTE: Availability needs to be tested to ensure that another process is not working on this this layer. </p>

</div>
</div>
<a class="anchor" id="a05a80bc73c19aad89860406345b3b733"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Seg3D::LayerManager::CheckLayerExistence </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>layer_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Core::ActionContextHandle&#160;</td>
          <td class="paramname"><em>context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SandboxID&#160;</td>
          <td class="paramname"><em>sandbox</em> = <code>-1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>CHECKLAYEREXISTENCE: Check whether a layer exists. If it does not exist, the function returns and reports the error in the context </p>

</div>
</div>
<a class="anchor" id="a56c8ca57a178e5d07a82cb7184871d0a"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Seg3D::LayerManager::CheckLayerExistence </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>layer_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SandboxID&#160;</td>
          <td class="paramname"><em>sandbox</em> = <code>-1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Check whether a layer exists. If it does not exist, the function returns false. </p>

</div>
</div>
<a class="anchor" id="aa7579b4f6397a56b6f00c24713523b3c"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Seg3D::LayerManager::CheckLayerExistenceAndType </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>layer_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Core::VolumeType&#160;</td>
          <td class="paramname"><em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Core::ActionContextHandle&#160;</td>
          <td class="paramname"><em>context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SandboxID&#160;</td>
          <td class="paramname"><em>sandbox</em> = <code>-1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>CHECKLAYEREXISTENCEANDTYPE: Check whether a layer exists and whether it is of the right type. If it does not exist or is not of the right type, the function returns the error in the context. </p>

</div>
</div>
<a class="anchor" id="a1f107644b0686b27e39596c8d1e941c2"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Seg3D::LayerManager::CheckLayerSize </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>layer_id1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>layer_id2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Core::ActionContextHandle&#160;</td>
          <td class="paramname"><em>context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SandboxID&#160;</td>
          <td class="paramname"><em>sandbox</em> = <code>-1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>CHECKLAYERSIZE: Check whether a layer has the right size. If it does not have the right size, the function returns false and returns the error in the context. </p>

</div>
</div>
<a class="anchor" id="aafe0a13849b188e6daabf09d1d3e910e"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Seg3D::LayerManager::CheckSandboxExistence </td>
          <td>(</td>
          <td class="paramtype">SandboxID&#160;</td>
          <td class="paramname"><em>sandbox</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Core::ActionContextHandle&#160;</td>
          <td class="paramname"><em>context</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>CHECKSANDBOXEXISTENCE: Check whether a sandbox exists. If it does not exist, the function returns false and reports the error in the context . </p>

</div>
</div>
<a class="anchor" id="a0d220e1ee5724c5b03bcd6b315fcbffe"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Seg3D::LayerManager::CreateAndLockDataLayer </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_core_1_1_grid_transform.html">Core::GridTransform</a>&#160;</td>
          <td class="paramname"><em>transform</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">LayerHandle &amp;&#160;</td>
          <td class="paramname"><em>layer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_seg3_d_1_1_layer_meta_data.html">LayerMetaData</a> &amp;&#160;</td>
          <td class="paramname"><em>meta_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_seg3_d_1_1_layer_manager.html#af5b4b2b6539f8fbde47c9edcae1f866f">filter_key_type</a>&#160;</td>
          <td class="paramname"><em>key</em> = <code><a class="el" href="class_seg3_d_1_1_layer_manager.html#af5b4b2b6539f8fbde47c9edcae1f866f">filter_key_type</a>(&#160;0&#160;)</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SandboxID&#160;</td>
          <td class="paramname"><em>sandbox</em> = <code>-1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>CREATEANDLOCKDATALAYER: Create a new data layer and lock it into the CREATING_C mode. NOTE: This function can <em>only</em> be called from the Application thread. </p>

</div>
</div>
<a class="anchor" id="ab935c19fac3f21a85af7c7912ecb1937"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Seg3D::LayerManager::CreateAndLockMaskLayer </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_core_1_1_grid_transform.html">Core::GridTransform</a>&#160;</td>
          <td class="paramname"><em>transform</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">LayerHandle &amp;&#160;</td>
          <td class="paramname"><em>layer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_seg3_d_1_1_layer_meta_data.html">LayerMetaData</a> &amp;&#160;</td>
          <td class="paramname"><em>meta_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_seg3_d_1_1_layer_manager.html#af5b4b2b6539f8fbde47c9edcae1f866f">filter_key_type</a>&#160;</td>
          <td class="paramname"><em>key</em> = <code><a class="el" href="class_seg3_d_1_1_layer_manager.html#af5b4b2b6539f8fbde47c9edcae1f866f">filter_key_type</a>(&#160;0&#160;)</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SandboxID&#160;</td>
          <td class="paramname"><em>sandbox</em> = <code>-1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>CREATEANDLOCKMASKLAYER: Create a new mask layer and lock it into the CREATING_C mode. NOTE: This function can <em>only</em> be called from the Application thread. </p>

</div>
</div>
<a class="anchor" id="a1419e15bd606ea3a0bc0c9e72025eddf"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Seg3D::LayerManager::CreateCroppedLargeVolumeLayer </td>
          <td>(</td>
          <td class="paramtype">Core::LargeVolumeSchemaHandle&#160;</td>
          <td class="paramname"><em>schema</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_core_1_1_grid_transform.html">Core::GridTransform</a> &amp;&#160;</td>
          <td class="paramname"><em>crop_trans</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">LayerHandle &amp;&#160;</td>
          <td class="paramname"><em>layer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_seg3_d_1_1_layer_meta_data.html">LayerMetaData</a> &amp;&#160;</td>
          <td class="paramname"><em>meta_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SandboxID&#160;</td>
          <td class="paramname"><em>sandbox</em> = <code>-1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Create a cropped version of a large volume. NOTE: This function can <em>only</em> be called from the Application thread. </p>

</div>
</div>
<a class="anchor" id="a1083cc4708db8a263bee0b9bb7332d96"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Seg3D::LayerManager::DispatchDeleteLayer </td>
          <td>(</td>
          <td class="paramtype">LayerHandle&#160;</td>
          <td class="paramname"><em>layer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_seg3_d_1_1_layer_manager.html#af5b4b2b6539f8fbde47c9edcae1f866f">filter_key_type</a>&#160;</td>
          <td class="paramname"><em>key</em> = <code><a class="el" href="class_seg3_d_1_1_layer_manager.html#af5b4b2b6539f8fbde47c9edcae1f866f">filter_key_type</a>(&#160;0&#160;)</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SandboxID&#160;</td>
          <td class="paramname"><em>sandbox</em> = <code>-1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>DISPATCHDELETELAYER: Delete the layer. This function will relay a call to the Application thread if needed. </p>

</div>
</div>
<a class="anchor" id="aa8dd5c05e9c17784da10356313e79f49"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Seg3D::LayerManager::DispatchInsertDataSliceIntoLayer </td>
          <td>(</td>
          <td class="paramtype">DataLayerHandle&#160;</td>
          <td class="paramname"><em>layer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Core::DataSliceHandle&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ProvenanceID&#160;</td>
          <td class="paramname"><em>provid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_seg3_d_1_1_layer_manager.html#af5b4b2b6539f8fbde47c9edcae1f866f">filter_key_type</a>&#160;</td>
          <td class="paramname"><em>key</em> = <code><a class="el" href="class_seg3_d_1_1_layer_manager.html#af5b4b2b6539f8fbde47c9edcae1f866f">filter_key_type</a>(&#160;0&#160;)</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SandboxID&#160;</td>
          <td class="paramname"><em>sandbox</em> = <code>-1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>DISPATCHINSERTDATASLICEINTOLAYER: Insert a data slice into a data layer. </p>

</div>
</div>
<a class="anchor" id="ad874c5313e7d78a152d43c9001cccfd4"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Seg3D::LayerManager::DispatchInsertDataSlicesIntoLayer </td>
          <td>(</td>
          <td class="paramtype">DataLayerHandle&#160;</td>
          <td class="paramname"><em>layer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; Core::DataSliceHandle &gt;&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ProvenanceID&#160;</td>
          <td class="paramname"><em>provid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_seg3_d_1_1_layer_manager.html#af5b4b2b6539f8fbde47c9edcae1f866f">filter_key_type</a>&#160;</td>
          <td class="paramname"><em>key</em> = <code><a class="el" href="class_seg3_d_1_1_layer_manager.html#af5b4b2b6539f8fbde47c9edcae1f866f">filter_key_type</a>(&#160;0&#160;)</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SandboxID&#160;</td>
          <td class="paramname"><em>sandbox</em> = <code>-1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>DISPATCHINSERTDATASLICEINTOLAYER: Insert a data slice into a data layer. </p>

</div>
</div>
<a class="anchor" id="ad19a669adb7aa27218a1c5f06ceb593b"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Seg3D::LayerManager::DispatchInsertDataVolumeIntoLayer </td>
          <td>(</td>
          <td class="paramtype">DataLayerHandle&#160;</td>
          <td class="paramname"><em>layer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Core::DataVolumeHandle&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ProvenanceID&#160;</td>
          <td class="paramname"><em>provid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_seg3_d_1_1_layer_manager.html#af5b4b2b6539f8fbde47c9edcae1f866f">filter_key_type</a>&#160;</td>
          <td class="paramname"><em>key</em> = <code><a class="el" href="class_seg3_d_1_1_layer_manager.html#af5b4b2b6539f8fbde47c9edcae1f866f">filter_key_type</a>(&#160;0&#160;)</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SandboxID&#160;</td>
          <td class="paramname"><em>sandbox</em> = <code>-1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>DISPATCHINSERTDATAVOLUMEINTOLAYER: Insert a data volume into a data layer. This function will relay a call to the Application thread if needed. </p>

</div>
</div>
<a class="anchor" id="a0254b8a63ad97be40c5a95e95e74f450"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Seg3D::LayerManager::DispatchInsertMaskSliceIntoLayer </td>
          <td>(</td>
          <td class="paramtype">MaskLayerHandle&#160;</td>
          <td class="paramname"><em>layer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Core::MaskDataSliceHandle&#160;</td>
          <td class="paramname"><em>mask</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ProvenanceID&#160;</td>
          <td class="paramname"><em>provid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_seg3_d_1_1_layer_manager.html#af5b4b2b6539f8fbde47c9edcae1f866f">filter_key_type</a>&#160;</td>
          <td class="paramname"><em>key</em> = <code><a class="el" href="class_seg3_d_1_1_layer_manager.html#af5b4b2b6539f8fbde47c9edcae1f866f">filter_key_type</a>(&#160;0&#160;)</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SandboxID&#160;</td>
          <td class="paramname"><em>sandbox</em> = <code>-1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>DISPATCHINSERTMASKSLICEINTOLAYER: Insert a data slice into a data layer. </p>

</div>
</div>
<a class="anchor" id="ad28b4bb11538b215c28084145493c792"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Seg3D::LayerManager::DispatchInsertMaskSlicesIntoLayer </td>
          <td>(</td>
          <td class="paramtype">MaskLayerHandle&#160;</td>
          <td class="paramname"><em>layer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; Core::MaskDataSliceHandle &gt;&#160;</td>
          <td class="paramname"><em>mask</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ProvenanceID&#160;</td>
          <td class="paramname"><em>provid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_seg3_d_1_1_layer_manager.html#af5b4b2b6539f8fbde47c9edcae1f866f">filter_key_type</a>&#160;</td>
          <td class="paramname"><em>key</em> = <code><a class="el" href="class_seg3_d_1_1_layer_manager.html#af5b4b2b6539f8fbde47c9edcae1f866f">filter_key_type</a>(&#160;0&#160;)</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SandboxID&#160;</td>
          <td class="paramname"><em>sandbox</em> = <code>-1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>DISPATCHINSERTMASKSLICESINTOLAYER: Insert a data slice into a data layer. </p>

</div>
</div>
<a class="anchor" id="a198e32c55970213d7d9f19b43253547a"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Seg3D::LayerManager::DispatchInsertMaskVolumeIntoLayer </td>
          <td>(</td>
          <td class="paramtype">MaskLayerHandle&#160;</td>
          <td class="paramname"><em>layer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Core::MaskVolumeHandle&#160;</td>
          <td class="paramname"><em>mask</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ProvenanceID&#160;</td>
          <td class="paramname"><em>provid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_seg3_d_1_1_layer_manager.html#af5b4b2b6539f8fbde47c9edcae1f866f">filter_key_type</a>&#160;</td>
          <td class="paramname"><em>key</em> = <code><a class="el" href="class_seg3_d_1_1_layer_manager.html#af5b4b2b6539f8fbde47c9edcae1f866f">filter_key_type</a>(&#160;0&#160;)</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SandboxID&#160;</td>
          <td class="paramname"><em>sandbox</em> = <code>-1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>DISPATCHINSERTMASKVOLUMEINTOLAYER: Insert a mask volume into a mask layer. This function will relay a call to the Application thread if needed. </p>

</div>
</div>
<a class="anchor" id="a5b805765b4765a8b2f410b4c57bc194a"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Seg3D::LayerManager::DispatchInsertVolumeIntoLayer </td>
          <td>(</td>
          <td class="paramtype">LayerHandle&#160;</td>
          <td class="paramname"><em>layer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Core::VolumeHandle&#160;</td>
          <td class="paramname"><em>mask</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ProvenanceID&#160;</td>
          <td class="paramname"><em>provid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_seg3_d_1_1_layer_manager.html#af5b4b2b6539f8fbde47c9edcae1f866f">filter_key_type</a>&#160;</td>
          <td class="paramname"><em>key</em> = <code><a class="el" href="class_seg3_d_1_1_layer_manager.html#af5b4b2b6539f8fbde47c9edcae1f866f">filter_key_type</a>(&#160;0&#160;)</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SandboxID&#160;</td>
          <td class="paramname"><em>sandbox</em> = <code>-1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>DISPATCHINSERTVOLUMEINTOLAYER: Insert a mask or data volume into a layer. This function will relay a call to the Application thread if needed. </p>

</div>
</div>
<a class="anchor" id="a0f30c636cf1a4eb3f806c5876b00e431"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Seg3D::LayerManager::DispatchUnlockLayer </td>
          <td>(</td>
          <td class="paramtype">LayerHandle&#160;</td>
          <td class="paramname"><em>layer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_seg3_d_1_1_layer_manager.html#af5b4b2b6539f8fbde47c9edcae1f866f">filter_key_type</a>&#160;</td>
          <td class="paramname"><em>key</em> = <code><a class="el" href="class_seg3_d_1_1_layer_manager.html#af5b4b2b6539f8fbde47c9edcae1f866f">filter_key_type</a>(&#160;0&#160;)</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SandboxID&#160;</td>
          <td class="paramname"><em>sandbox</em> = <code>-1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>DISPATCHUNLOCKLAYER: Change the layer data_state back to available. This function will relay a call to the Application thread if needed. </p>

</div>
</div>
<a class="anchor" id="a74a5b6f5055c5904925eea2a2a619084"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Seg3D::LayerManager::DispatchUnlockOrDeleteLayer </td>
          <td>(</td>
          <td class="paramtype">LayerHandle&#160;</td>
          <td class="paramname"><em>layer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_seg3_d_1_1_layer_manager.html#af5b4b2b6539f8fbde47c9edcae1f866f">filter_key_type</a>&#160;</td>
          <td class="paramname"><em>key</em> = <code><a class="el" href="class_seg3_d_1_1_layer_manager.html#af5b4b2b6539f8fbde47c9edcae1f866f">filter_key_type</a>(&#160;0&#160;)</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SandboxID&#160;</td>
          <td class="paramname"><em>sandbox</em> = <code>-1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>DISPATCHUNLOCKORDELETELAYER: Unlock layer if valid, delete otherwise. This function will relay a call to the Application thread if needed. </p>

</div>
</div>
<a class="anchor" id="af9dc1cc52b7d354d3fdfb349b80fa0e3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">DataLayerHandle Seg3D::LayerManager::find_data_layer_by_id </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>layer_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SandboxID&#160;</td>
          <td class="paramname"><em>sandbox</em> = <code>-1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>GET_DATA_LAYER_BY_ID: this function returns a handle to the layer with the id that is passed. If a sandbox number is given, it searches in that sandbox instead. </p>

</div>
</div>
<a class="anchor" id="a86a058090797095cce9901312ad86f41"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LayerGroupHandle Seg3D::LayerManager::find_group </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>group_id</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>FIND_GROUP: this function returns the group with the id that is passed. </p>

</div>
</div>
<a class="anchor" id="a8265add81a4791f4d70ca7029c4246df"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LayerGroupHandle Seg3D::LayerManager::find_group </td>
          <td>(</td>
          <td class="paramtype">ProvenanceID&#160;</td>
          <td class="paramname"><em>provenance_id</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>FIND_GROUP: this function returns the group with the provenance id that is passed. </p>

</div>
</div>
<a class="anchor" id="a589090867f58411c3acec2a2730c0764"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LayerHandle Seg3D::LayerManager::find_layer_by_id </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>layer_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SandboxID&#160;</td>
          <td class="paramname"><em>sandbox</em> = <code>-1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>FIND_LAYER_BY_ID: Find the layer with the given ID. If a sandbox number is given, it searches in that sandbox instead. </p>

</div>
</div>
<a class="anchor" id="a44425d3d5700aca9e2c805a52db89a4b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LayerHandle Seg3D::LayerManager::find_layer_by_name </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>layer_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SandboxID&#160;</td>
          <td class="paramname"><em>sandbox</em> = <code>-1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>FIND_LAYER_BY_NAME: This function returns a handle to a layer with the name that is passed. If a sandbox number is given, it searches in that sandbox instead. </p>

</div>
</div>
<a class="anchor" id="a7ba7e81deaa0836d626c6b56a5beafbb"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LayerHandle Seg3D::LayerManager::find_layer_by_provenance_id </td>
          <td>(</td>
          <td class="paramtype">ProvenanceID&#160;</td>
          <td class="paramname"><em>provenance_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SandboxID&#160;</td>
          <td class="paramname"><em>sandbox</em> = <code>-1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>GET_LAYER_BY_PROVENANCE_ID: This function returns a handle to a layer with the provenance id that was given. If a sandbox number is given, it searches in that sandbox instead. </p>

</div>
</div>
<a class="anchor" id="a32afbc14bf7e4d50a1856134918dc545"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MaskLayerHandle Seg3D::LayerManager::find_mask_layer_by_id </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>layer_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SandboxID&#160;</td>
          <td class="paramname"><em>sandbox</em> = <code>-1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>GET_MASK_LAYER_BY_ID: this function returns a handle to the layer with the id that is passed. If a sandbox number is given, it searches in that sandbox instead. </p>

</div>
</div>
<a class="anchor" id="a7355882fd6db0ea7c248411457fe6184"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">DataLayerHandle Seg3D::LayerManager::FindDataLayer </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>layer_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SandboxID&#160;</td>
          <td class="paramname"><em>sandbox</em> = <code>-1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>FINDDATALAYER: Find a data layer inside the layer manager </p>

</div>
</div>
<a class="anchor" id="a5fe479a5f23845f65e67a82efee00732"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">LayerGroupHandle Seg3D::LayerManager::FindGroup </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>group_id</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>FINDGROUP: Find a layer inside the layer manager </p>

</div>
</div>
<a class="anchor" id="a56c1a4e0d6ff86145845833ad782adc5"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">LayerGroupHandle Seg3D::LayerManager::FindGroup </td>
          <td>(</td>
          <td class="paramtype">ProvenanceID&#160;</td>
          <td class="paramname"><em>prov_id</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>FINDGROUP: Find a layer inside the layer manager </p>

</div>
</div>
<a class="anchor" id="a9f95472ca8a83d87b6ca3414bc23a1eb"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">LayerHandle Seg3D::LayerManager::FindLayer </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>layer_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SandboxID&#160;</td>
          <td class="paramname"><em>sandbox</em> = <code>-1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>FINDLAYER: Find a layer inside the layer manager </p>

</div>
</div>
<a class="anchor" id="a737211decd5f7df6ae1304ccba5720ea"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">LayerHandle Seg3D::LayerManager::FindLayer </td>
          <td>(</td>
          <td class="paramtype">ProvenanceID&#160;</td>
          <td class="paramname"><em>prov_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SandboxID&#160;</td>
          <td class="paramname"><em>sandbox</em> = <code>-1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>FINDLAYER: Find a layer inside the layer manager </p>

</div>
</div>
<a class="anchor" id="adc4973c70d95e718b9008d2012628073"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">MaskLayerHandle Seg3D::LayerManager::FindMaskLayer </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>layer_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SandboxID&#160;</td>
          <td class="paramname"><em>sandbox</em> = <code>-1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>FINDMASKLAYER: Find a mask layer inside the layer manager </p>

</div>
</div>
<a class="anchor" id="ac991ad9a369f330e27428fdff5e3570f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LayerHandle Seg3D::LayerManager::get_active_layer </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>GET_ACTIVE_LAYER: This function returns a handle to the active layer Locks: StateEngine </p>

</div>
</div>
<a class="anchor" id="a00616e69ce19220bef40a26fdbb7e271"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t Seg3D::LayerManager::get_group_position </td>
          <td>(</td>
          <td class="paramtype">LayerGroupHandle&#160;</td>
          <td class="paramname"><em>group</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>GET_GROUP_POSITION: Returns the position of the given group. </p>

</div>
</div>
<a class="anchor" id="a5892b54bd1041723476d5dced0240abc"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Seg3D::LayerManager::get_groups </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; LayerGroupHandle &gt; &amp;&#160;</td>
          <td class="paramname"><em>groups</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>GET_GROUPS: this function copies the groups into the vector that is passed </p>

</div>
</div>
<a class="anchor" id="aa9fecbfb0bc74ca81adc4fd315ea17bb"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Seg3D::LayerManager::get_layer_names </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; LayerIDNamePair &gt; &amp;&#160;</td>
          <td class="paramname"><em>layer_names</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>type</em> = <code>Core::VolumeType::ALL_E</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>GET_LAYER_NAMES: This function returns a vector of layer ID and name pairs of the specified layer type. </p>

</div>
</div>
<a class="anchor" id="abe8dc4a433129db36e6707939b9f0ce6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Seg3D::LayerManager::get_layers </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; LayerHandle &gt; &amp;&#160;</td>
          <td class="paramname"><em>layers</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>GET_LAYERS: Get all layers in top to bottom order. </p>

</div>
</div>
<a class="anchor" id="aabbb24c4cf485b353550efedd0cfda9d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LayerManager::mutex_type &amp; Seg3D::LayerManager::get_mutex </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>GET_MUTEX: Get the mutex, so it can be locked by the interface that is built on top of this </p>

</div>
</div>
<a class="anchor" id="a41c39a59b46b471e2d88fa2fe174c8f6"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual int Seg3D::LayerManager::get_session_priority </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns the session priority of the state handler. State handlers with higher priorities gets loaded earlier than those with lower priorities. By default this functions returns -1, which means that the state handler won't be saved/loaded by the state engine. </p>

<p>Reimplemented from <a class="el" href="class_core_1_1_state_handler.html#a1127d11adad3b949e43544787e7496d3">Core::StateHandler</a>.</p>

</div>
</div>
<a class="anchor" id="a0435095575132821b55639e4b9df1299"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">LayerManager::id_count_type Seg3D::LayerManager::GetLayerIdCount </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>GETLAYERIDCOUNT: Get the current count of the group and layer ids </p>

</div>
</div>
<a class="anchor" id="a19a3f8c4d8f81cc84df6472323f7bede"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">LayerManager::id_count_type Seg3D::LayerManager::GetLayerInvalidIdCount </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>GETLAYERINVALIDIDCOUNT: Get a default id count that has no valid ids. </p>

</div>
</div>
<a class="anchor" id="aeaa1d8d15a73611aa60c80d4e7ccce3b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Seg3D::LayerManager::is_sandbox </td>
          <td>(</td>
          <td class="paramtype">SandboxID&#160;</td>
          <td class="paramname"><em>sandbox_id</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>IS_SANDBOX: Check whether the given sandbox ID is valid. NOTE: -1 is considered valid because it represents the normal context. </p>

</div>
</div>
<a class="anchor" id="ae01ae8778f0373920984a90349c2c7d9"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Seg3D::LayerManager::LockForProcessing </td>
          <td>(</td>
          <td class="paramtype">LayerHandle&#160;</td>
          <td class="paramname"><em>layer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_seg3_d_1_1_layer_manager.html#af5b4b2b6539f8fbde47c9edcae1f866f">filter_key_type</a>&#160;</td>
          <td class="paramname"><em>key</em> = <code><a class="el" href="class_seg3_d_1_1_layer_manager.html#af5b4b2b6539f8fbde47c9edcae1f866f">filter_key_type</a>(&#160;0&#160;)</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>LOCKFORPROCESSING: Change the layer data_state to PROCESSING_C. NOTE: This function can <em>only</em> be called from the Application thread. </p>

</div>
</div>
<a class="anchor" id="aab662b45423f8707db52bb2db4912e7f"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Seg3D::LayerManager::LockForUse </td>
          <td>(</td>
          <td class="paramtype">LayerHandle&#160;</td>
          <td class="paramname"><em>layer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_seg3_d_1_1_layer_manager.html#af5b4b2b6539f8fbde47c9edcae1f866f">filter_key_type</a>&#160;</td>
          <td class="paramname"><em>key</em> = <code><a class="el" href="class_seg3_d_1_1_layer_manager.html#af5b4b2b6539f8fbde47c9edcae1f866f">filter_key_type</a>(&#160;0&#160;)</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>LOCKFORUSE: Change the layer data_state to IN_USE_C. NOTE: This function can <em>only</em> be called from the Application thread. </p>

</div>
</div>
<a class="anchor" id="a1658cca681b459e9664e5c84fe113e44"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Seg3D::LayerManager::post_load_states </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_core_1_1_state_i_o.html">Core::StateIO</a> &amp;&#160;</td>
          <td class="paramname"><em>state_io</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>POST_LOAD_STATES: this function creates the layers who's information was saved to file, and then tells them to populate their state variables from file </p>

<p>Reimplemented from <a class="el" href="class_core_1_1_state_handler.html#a537662153224e79997510ca9b4e11ac2">Core::StateHandler</a>.</p>

</div>
</div>
<a class="anchor" id="a7a8dfca832b62ff0d923e32ae072707b"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Seg3D::LayerManager::post_save_states </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_core_1_1_state_i_o.html">Core::StateIO</a> &amp;&#160;</td>
          <td class="paramname"><em>state_io</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>POST_SAVE_STATES: This function is called after the <a class="el" href="class_seg3_d_1_1_layer_manager.html">LayerManager</a>'s states have been saved and then tells the groups to save their states as well. </p>

<p>Reimplemented from <a class="el" href="class_core_1_1_state_handler.html#a085c3f26360fe6331d67c7e99abcef86">Core::StateHandler</a>.</p>

</div>
</div>
<a class="anchor" id="a64b80e5632ed80b27dff3b539f5adbf5"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Seg3D::LayerManager::pre_load_states </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_core_1_1_state_i_o.html">Core::StateIO</a> &amp;&#160;</td>
          <td class="paramname"><em>state_io</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>PRE_LOAD_STATES: this function clears out all existing layers before we load a project from file </p>

<p>Reimplemented from <a class="el" href="class_core_1_1_state_handler.html#aad367764eba3c97af1d6aab770859278">Core::StateHandler</a>.</p>

</div>
</div>
<a class="anchor" id="a175f6e5cee9f1b6418511da828fdc5fe"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Seg3D::LayerManager::pre_save_states </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_core_1_1_state_i_o.html">Core::StateIO</a> &amp;&#160;</td>
          <td class="paramname"><em>state_io</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>PRE_SAVE_STATES: This function is called before the <a class="el" href="class_seg3_d_1_1_layer_manager.html">LayerManager</a>'s states are being saved </p>

<p>Reimplemented from <a class="el" href="class_core_1_1_state_handler.html#a5126ca0d01d5ffb07b3264d9813e5f8f">Core::StateHandler</a>.</p>

</div>
</div>
<a class="anchor" id="af11d24bcd84655b75f5b6f0a2d5290bd"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Seg3D::LayerManager::SetLayerIdCount </td>
          <td>(</td>
          <td class="paramtype">id_count_type&#160;</td>
          <td class="paramname"><em>id_count</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>SETLAYERIDCOUNT: Set the current count of group and layer NOTE: This function should only be called by the undo buffer </p>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a class="anchor" id="add6bfaf895747a838ced64b78eb2580f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">boost::signals2::signal&lt; void ( LayerHandle ) &gt; Seg3D::LayerManager::active_layer_changed_signal_</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>ACTIVE_LAYER_CHANGED_SIGNAL: This signal is triggered after the active layer is changed </p>

</div>
</div>
<a class="anchor" id="abfebeda58b3618734084dd98793c1fc1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">boost::signals2::signal&lt; void () &gt; Seg3D::LayerManager::groups_reordered_signal_</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>GROUPS_REORDERED_SIGNAL: Triggered when layer groups have been reordered. </p>

</div>
</div>
<a class="anchor" id="a18bbc7c07d7b9056f1d3fbc8bfffeecd"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">boost::signals2::signal&lt; void ( LayerHandle ) &gt; Seg3D::LayerManager::layer_data_changed_signal_</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>LAYER_DATA_CHANGED_SIGNAL: Triggered when the layer data state is changed. This tracks whether layers are being locked for processing and when new data will be available </p>

</div>
</div>
<a class="anchor" id="abe84f7e3d5c8ffbc806996a27301f08b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">boost::signals2::signal&lt; void ( LayerHandle, bool ) &gt; Seg3D::LayerManager::layer_inserted_signal_</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>LAYER_INSERTED_SIGNAL: Triggered after a layer has been inserted. The first parameter is the new layer. The second parameter indicates whether a new group has been created. </p>

</div>
</div>
<a class="anchor" id="a3e1c3977cd80f14ccfeba0dd6d597cd6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">boost::signals2::signal&lt; void ( std::string, std::string ) &gt; Seg3D::LayerManager::layer_name_changed_signal_</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>LAYER_NAME_CHANGED_SIGNAL: Triggered when the name of a layer has changed. The first parameter is the layer ID, the second is the new name for that layer. </p>

</div>
</div>
<a class="anchor" id="a94428982c6e0c64ce461b73f77e8eed9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">boost::signals2::signal&lt; void ( LayerHandle ) &gt; Seg3D::LayerManager::layer_volume_changed_signal_</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>LAYER_VOLUME_CHANGED_SIGNAL: Triggered when the volume of a layer has changed. The first parameter is the layer handle. </p>

</div>
</div>
<a class="anchor" id="a81266b692030472bae858897b7cffb3b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">boost::signals2::signal&lt; void() &gt; Seg3D::LayerManager::layers_changed_signal_</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>LAYERS_CHANGED_SIGNAL: Triggered when layers are inserted, deleted, or reordered. It is a combination of layer_inserted_signal_, layers_deleted_signal_, layers_reordered_signal_, and groups_reordered_signal_. NOTE: It is always triggered after the individual ones. </p>

</div>
</div>
<a class="anchor" id="a092d66815f1810362a57d814b9384244"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">boost::signals2::signal&lt; void ( std::vector&lt; std::string &gt;, std::vector&lt; std::string &gt;, bool ) &gt; Seg3D::LayerManager::layers_deleted_signal_</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>LAYERS_DELETED_SIGNAL: Triggered after layers have been deleted. The first parameter is a vector of deleted layer IDs. The second parameter is a vector of group IDs from which the layers have been deleted. The third parameter indicates whether any group has been deleted. </p>

</div>
</div>
<a class="anchor" id="a98d52c7359223e1d685a35a9e01b35f9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">boost::signals2::signal&lt; void ( std::string ) &gt; Seg3D::LayerManager::layers_reordered_signal_</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>LAYERS_REORDERED_SIGNAL: Triggered when the order of the layers has been changed. The parameter is the ID of the group whose layers have been reordered. </p>

</div>
</div>
<a class="anchor" id="a6bbe024f1636477fadb115321bcc79bb"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">boost::signals2::signal&lt; void() &gt; Seg3D::LayerManager::mask_layer_isosurface_created_signal_</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>MASK_LAYER_ISOSURFACE_CREATED_SIGNAL: Triggered when isosurface is created. </p>

</div>
</div>
<a class="anchor" id="aa3bd8519296a6bafb3f0fd491c19cf56"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">boost::signals2::signal&lt; void() &gt; Seg3D::LayerManager::mask_layer_isosurface_deleted_signal_</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>MASK_LAYER_ISOSURFACE_DELETED_SIGNAL: Triggered when isosurface is deleted. </p>

</div>
</div>
<a class="anchor" id="afab232acf3826d088e78d0f67cf998a0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">boost::signals2::signal&lt; void ( SandboxID ) &gt; Seg3D::LayerManager::sandbox_created_signal_</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>SANDBOX_CREATED_SIGNAL_: Triggered when a sandbox has been created. </p>

</div>
</div>
<a class="anchor" id="a9564ddf6ce3cf9c6e624b083a40b2fef"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">boost::signals2::signal&lt; void ( SandboxID ) &gt; Seg3D::LayerManager::sandbox_deleted_signal_</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>SANDBOX_DELETED_SIGNAL_: Triggered when a sandbox has been deleted. </p>

</div>
</div>
<a class="anchor" id="ab128d108337ee5d844dc14f32aca9fd0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">boost::signals2::signal&lt; void ( SandboxID, std::string ) &gt; Seg3D::LayerManager::script_begin_signal_</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>SCRIPT_BEGIN_SIGNAL: Indicate the beginning of a script. The first parameter is sandbox in which the script is running, the second parameter is the the script name. NOTE: The sandbox can be used to uniquely identify a running script. </p>

</div>
</div>
<a class="anchor" id="a806f64f78e6264892f7780561ca8752a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">boost::signals2::signal&lt; void ( SandboxID ) &gt; Seg3D::LayerManager::script_end_signal_</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>SCRIPT_END_SIGNAL: Indicate the end of a script. The parameter is the sandbox in which the script is running. </p>

</div>
</div>
<a class="anchor" id="a32674ca1b7d4f9431c0ab401e25b9b8c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">boost::signals2::signal&lt; void ( SandboxID, std::string, size_t, size_t ) &gt; Seg3D::LayerManager::script_progress_signal_</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>SCRIPT_PROGRESS_SIGNAL: Report the progress of a script. The first parameter is the sandbox in which the script is running. The second parameter is the name of the current running step. The third parameter is the number of steps that have finished. The fourth parameter is the total number of steps. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>Application/Layer/<a class="el" href="_layer_manager_8h_source.html">LayerManager.h</a></li>
<li>Application/Layer/LayerManager.cc</li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Wed Jun 29 2016 22:44:36 for Seg3D by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.10
</small></address>
</body>
</html>
